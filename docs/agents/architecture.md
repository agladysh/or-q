# OR-Q: Architectural Reference Document

**Version:** 1.0 **Status:** Live **Date:** 2025-08-14

> [!WARNING] _This document was generated by an AI and may contain mistakes._

---

## Part I: Introduction & Guiding Principles

### 1.0 Overview

OR-Q is a plugin-based command-line interface (CLI) designed for orchestrating complex command pipelines, with a primary
focus on interacting with AI models and services. It provides a powerful, extensible environment for developers and
power-users to compose and execute workflows from a variety of functional building blocks provided by plugins.

This document provides a definitive architectural reference for the OR-Q system. Its purpose is to establish a clear and
honest ground truth to guide current and future development.

### 2.0 Project Background & Development Philosophy

#### 2.1 Prototype Phase

The OR-Q project was initiated on 2025-08-05. The current system is the result of a rapid, initial development phase and
should be understood as a functional prototype. Its design reflects this context.

#### 2.2 Design Philosophy

The core development strategy has been to balance two competing needs:

1. **Immediate Utility:** To rapidly implement a working, end-to-end system that is immediately useful.
2. **Long-Term Rigor:** To build on a foundation that can mature into a robust, performant, and formally-designed
   engine.

This has led to pragmatic design trade-offs where simple, fast-to-implement solutions were chosen for the prototype,
while their limitations and a clear path for their evolution were simultaneously and transparently documented in project
artifacts like `TODO.md`.

This document is therefore structured to reflect this philosophy, describing both the current "as-is" architecture of
the prototype and the planned "to-be" architecture of the mature system.

### 3.0 Document Scope & Principles for Maintenance

#### 3.1 Scope

This document is strictly architectural. It covers the system's conceptual structure, the rationale behind its design,
its current limitations, and its planned evolution. It explicitly excludes implementation guides, API references, and
tutorials, which belong in separate documentation.

#### 3.2 Guiding Principles for Maintenance

To maintain the integrity of this document, any contributing agent (human or AI) must adhere to the following
principles:

- **Principle of Objectivity:** Maintain a neutral, professional tone. Describe the system without praise or pejorative
  language.
- **Principle of Separation of Concerns:** Strictly separate the "as-is" prototype architecture from the "to-be" target
  architecture.
- **Principle of Aletheia (Truthful Accounting):** State all known architectural limitations and design trade-offs
  clearly, focusing on causality and consequences, not justification.

---

## Part II: The OR-Q Architecture: A Formal System

### 4.0 Program Representation

The fundamental concept in OR-Q is the "program," an abstract sequence of instructions. This program is held in memory
in a canonical format and can be generated from multiple concrete syntaxes.

#### 4.1 Current Representation (As-Is)

The canonical in-memory representation is the `Arguments` type, defined in `@or-q/lib` as `(string | Arguments)[]`. This
nestable array of strings is generated from two sources:

- **ARGV Form:** Command-line arguments are parsed directly into this structure.
- **YAML Form:** The `@or-q/plugin-yaml-script` compiles YAML files into the `Arguments` structure, using directives
  like `_JSON`, `_DATA`, and `_RAW` as syntax extensions for meta-programming. These are compile‑time directives — not
  executable commands. When used correctly inside YAML, they transform the script into the internal program form. If
  invoked directly as commands, they error by design (they are reserved placeholders).

#### 4.2 Target Representation (To-Be)

The documented architectural goal is to evolve this representation into a more formal `(command, arguments)` tuple,
where `arguments` is a schema-defined object.

#### 4.3 Rationale for Evolution

This transition is motivated by the need for a more robust and unambiguous program form that can support static
validation via schemas (e.g., `arktype`), which in turn enables first-class, typed, and optional arguments.

### 5.0 The Execution Model

The runtime executes a program using a simple interpreter that consumes the instruction stream sequentially.

#### 5.1 Current Model (The Interpreter)

The execution model is analogous to a stack-based language like Forth. The `PluginRuntime.runCommands` loop consumes the
`Arguments` array one instruction at a time (`args.shift()`). This instruction operates on a single, persistent `input`
data value (`string | Readable`), and its output becomes the `input` for the next instruction.

#### 5.2 Target Model (The Engine)

The planned evolution is to expand the `input` data contract to include structured objects (e.g., JavaScript objects and
arrays). This allows data to be passed between instructions directly in memory.

#### 5.3 Rationale for Evolution

The primary drivers are performance and simplicity. Direct object passing will eliminate the significant overhead and
command clutter (e.g., `jp`, `unquote`, `to-json`) caused by the current text-only contract.

### 6.0 The Extensibility Model: The Plugin Contract

The system's functionality is extended via a formal contract that creates a stable boundary between the core runtime and
its plugins.

#### 6.1 The Stable Contract (`@or-q/lib`)

This library defines the core interfaces, primarily `IPluginRuntime` and `Plugin`. This ensures plugins are decoupled
from the runtime's specific implementation.

#### 6.2 The Current Implementation (`@or-q/core`)

This package provides the concrete runtime, which implements the `IPluginRuntime` interface. It includes a plugin loader
that discovers compatible packages and a namespace manager that merges commands into a single, flat namespace.

### 7.0 Asset Management

The system provides a unified mechanism for plugins to bundle and access static resources.

#### 7.1 The `plugin:` Protocol

A namespaced URI scheme (e.g., `plugin:@or-q/plugin-name/path/to/asset.yaml`) is used to uniquely address resources,
preventing collisions between plugins.

#### 7.2 The Resolution Process

The `resolveAsset` function implements a fallback chain, attempting to find an asset first by its direct URI, and then
by searching via glob patterns if an unqualified name is given.

---

## Part III: Long-Term Vision & Future Directions

Beyond the core architectural refactoring, the project's `TODO.md` outlines a broader vision for the OR-Q ecosystem.

### 8.0 Broader Ecosystem & Product Vision

#### 8.1 Multi-Modal Interfaces

The long-term plan includes moving beyond a purely CLI-based interface:

- **Visual Editor:** A visual no/low-code editor for composing and managing command pipelines.
- **MCP Server:** An implementation of a Model Context Protocol server, allowing OR-Q to act as a backend for other
  AI-native applications.

#### 8.2 Multi-Language Runtimes

To increase adoption and flexibility, there are plans to add code generation features to create bindings for other
languages, allowing OR-Q command pipelines to be constructed and executed from:

- **Lua:** Via Fengari bindings, enabling lightweight scripting with coroutines.
- **JavaScript/TypeScript:** Providing a native library interface for programmatic pipeline construction.

#### 8.3 Enhanced Resilience & Intelligence

- **HTTP Resilience:** Implement exponential backoff and other retry mechanisms for all `fetch` calls to make API
  interactions more robust.
- **Advanced Features:** Exploration of more experimental concepts, such as the "TRIZ bi-system."
