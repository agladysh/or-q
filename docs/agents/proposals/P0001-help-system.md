# P0001: Help System

Status: **DRAFT**

> [!WARNING] This document is partially generated by AI for AI and may contain mistakes.

## Summary

This proposal outlines the implementation of a comprehensive help system for OR-Q.

## Commands

### `@or-q/plugin-help`

All help commands replace input with their output.

- `help`: Lists all commands with the `help-command` tag in alphabetic order, with their desriptions.
- `help-commands`: List all commands with their descriptions, grouped by plugin
- `help-commands-by-tag "<tag>"`: List all commands with a tag. Tag is arbitrary.
- `help-command "<command>"`: Prints command description and usage string
- `help-plugins`: Lists all available plugins with their descriptions, sorted alphabetically
- `help-plugin "<plugin.name>"`: Shows detailed information about a specific plugin including its commands and assets
- `help-assets`: Lists all available assets (YAML scripts and other files) with their descriptions and plugin sources

Note that `help-asset` currently makes no sense, as there is no additional information to display

### `@or-q/plugin-discover`

- `discover`: Replaces input with JSON array of all commands with `discovery-command` tag in the form:
  `{"name":"command","description":"command description"}`
- `discover-commands`: Returns JSON array of all commands with full metadata including description, usage, tags, and
  plugin source
- `discover-plugins`: Returns JSON array of all plugins with their metadata, commands, and assets
- `discover-assets`: Returns JSON array of all assets with their metadata, content paths, and plugin sources

Note filtration commands are redundant, users may filter themselves arbitrarily with `jp`.

### `@or-q/plugin-yaml-script`

Support optional `description` field on assets to show in help

- `help-scripts`: Lists all available YAML scripts with their descriptions and usage information
- `help-script "<script>"`: Shows detailed help for a specific script including description, required plugins, and
  parameters
- `discover-scripts`: Returns JSON array of all YAML scripts with their metadata, requirements, and command structures
- `discover-script "<script>"`: displays full script YAML

### Other Plugins

#### Legacy Help-like Command Elimination

The following existing commands should be replaced by the new help/discover system:

**Commands to Replace with `help-*`** (stdout + pass-through pattern):

- `list-plugins` → `help-plugins`
- `list-assets` → `help-assets`
- `list-script-assets` → `help-scripts`

**Commands to Replace with `discover-*`** (JSON output pattern):

- `plugins-json` → `discover-plugins`
- `dump-macros` → `discover-macros` (plugin-specific)
- `dump-store` → `discover-store` (plugin-specific)

**Commands to Keep** (not help/discover related):

- `dump` (debugging tool for program arguments)
- Commands with similar names but different purposes

#### Help and Discover Commands

Adding new help and discover commands to other plugins is not in scope of this proposal.

## Reference Command Output Formats

Illustrative abbreviated references.

> [!NOTE] JSON outputs are pretty-printed here for readability. Implementations should return compact newline-termidated
> representations.

**`help` command output:**

```text
Available Commands:

Help Commands:
  help                 Show available help commands
  help-commands        List all commands grouped by plugin
  help-plugins         List all available plugins
  help-assets          List all available assets with descriptions

Discovery Commands:
  discover             List discovery commands as JSON
  discover-commands    List all commands with full metadata as JSON
  discover-plugins     List all plugins with metadata as JSON
  discover-assets      List all assets with metadata as JSON

Core Commands:
  echo                 replaces input with argument
  print                prints trimmed argument to stdout, passing input forward
  tee                  outputs end-trimmed input to stdout, passes it along untrimmed
  clear                replaces input with empty string
  input                forwards input (useful for program arguments sometimes)
  default              if input is empty, replaces it with argument
```

**`discover` command output:**

```json
[
  { "name": "discover", "description": "List discovery commands as JSON", "tags": ["discovery-command"] },
  {
    "name": "discover-commands",
    "description": "List all commands with full metadata as JSON",
    "tags": ["discovery-command"]
  },
  { "name": "discover-plugins", "description": "List all plugins with metadata as JSON", "tags": ["discovery-command"] }
]
```

**`help-commands` command output:**

```text
Commands by Plugin:

@or-q/plugin-core:
  echo                 replaces input with argument
  print                prints trimmed argument to stdout, passing input forward
  tee                  outputs end-trimmed input to stdout, passes it along untrimmed
  clear                replaces input with empty string
  ...

@or-q/plugin-fetch:
  fetch                fetches data from a provided URL, with input as request body

@or-q/plugin-openrouter-api:
  completions          feeds input to the OpenRouter completions API, requires OPENROUTER_API_KEY env variable
  conversation         starts or continues a conversation
  models               replaces input with OpenRouter models list
  ...
```

**`help-plugins` command output:**

```text
Available Plugins:

@or-q/plugin-core            OR-Q Plugin: Core Commands

@or-q/plugin-fetch           OR-Q Plugin: Basic HTTP Support

@or-q/plugin-openrouter-api  OR-Q Plugin: OpenRouter API Integration
...
```

**`discover-plugins` command output:**

```json
[
  {
    "name": "@or-q/plugin-core",
    "description": "OR-Q Plugin: Core Commands",
    "commands": ["echo", "print", "tee", "clear" /*...*/],
    "assets": []
  },
  {
    "name": "@or-q/plugin-fetch",
    "description": "OR-Q Plugin: Basic HTTP Support",
    "commands": ["fetch"],
    "assets": ["scripts/fetch-openai-instruct.yaml", "scripts/fetch-test.yaml"]
  }
  // ...
]
```

**`help-assets` command output:**

```text
Available Assets:

@or-q/plugin-fetch:
  scripts/fetch-openai-instruct.yaml    OpenAI-compatible chat completion request macro
  scripts/fetch-test.yaml               Test script for fetch functionality with Ollama

@or-q/plugin-openrouter-api:
  scripts/chat.yaml                     Interactive chat session
  scripts/list-free-models.yaml         List free models from OpenRouter
  ...
```

**`discover-assets` command output:**

```json
[
  {
    "name": "scripts/fetch-openai-instruct.yaml",
    "plugin": "@or-q/plugin-fetch",
    "description": "OpenAI-compatible chat completion request macro",
    "path": "plugin:@or-q/plugin-fetch/scripts/fetch-openai-instruct.yaml"
  },
  {
    "name": "scripts/chat.yaml",
    "plugin": "@or-q/plugin-openrouter-api",
    "description": "Interactive chat session",
    "path": "plugin:@or-q/plugin-openrouter-api/scripts/chat.yaml"
  }
  // ...
]
```

**`help-scripts` command output:**

```text
Available Scripts:

fetch-openai-instruct        OpenAI-compatible chat completion request macro
chat                         Interactive chat session
list-free-models             List free models from OpenRouter
...
```

**`help-script "chat"` command output:**

```text
Script: chat
Plugin: @or-q/plugin-openrouter-api
Description: Interactive chat session

Usage: pnpm or-q run chat

Required Plugins:
  - @or-q/plugin-openrouter-api
  - @or-q/plugin-store

Environment Variables:
  - OPENROUTER_API_KEY (required for API access)
```

## Design Principles

### 1. Programmatic Content Generation

All help commands are programmatic, using existing content:

- **Plugin metadata**: `Plugin.name` (existing) and `Plugin.description` (new field, re-export from Plugin's
  `package.json`)
- **Command descriptions**: Already present in command definitions
- **Runtime state**: Available plugins, commands, assets from runtime
- **No duplication**: No separate help content to maintain

### 2. Enhanced Command Metadata

Commands get an optional `tags` array for flexible categorization. Tags recognized by the help and discovery systems:

- `help-command`: Commands that provide help functionality
- `discovery-command`: Commands that provide discovery/metadata functionality

Plugins can use additional domain-specific tags as needed.

### 3. Separation of Concerns

- **Human-readable help**: `help` and `help-*` commands provide formatted, user-friendly output
- **Machine-readable data**: `discover` and `discover-*` commands provide structured data for programmatic use
- **Plugin-extensible**: Each plugin may export its own help and/or discovery commands

### 4. CLI Integration

When OR-Q is invoked with no arguments:

1. Output brief standard cli usage header
2. Check if `help` command exists in the runtime
3. If yes, execute it on general principles
4. If no, show a generic fallback message: `help command not available, install the @or-q/plugin-help npm package`

## Motivation

### Why This Approach

OR-Q's current help situation is problematic:

1. **User Onboarding**: New users cannot discover available functionality
2. **Plugin Discovery**: No way to understand what plugins provide
3. **Script Visibility**: YAML scripts are invisible without prior knowledge
4. **Developer Experience**: Plugin authors have no standard way to expose help
5. **Architectural Debt**: It is best to introduce breaking changes early, while we do not care about backwards
   compatibility

### Why Not Hierarchical Commands

A seemingly elegant alternative would be `help commands`, `help plugins`, etc. However, this is architecturally
impossible due to the way OR-Q's stack-based argument consumption is currently implemented:

The `help` command cannot determine if `commands` is an argument for the help command (e.g., "show me help about
commands") or a legitimate command name that should be left for the next pipeline stage.

## Future Work

After planned switch to the CS-correct program form, `help` command may become porcelain for other
`help-command-plumbing` commands, supporting the elegant alternative above.

## Code Impact Remarks

Non-exhaustive assessment.

### Core

- Remove `IPluginRuntime.usage()`
- Add mandatory `description` field on Plugin, and refactor all plugins to expose pkg.description sans `OR-Q Plugin:`
  through it
- Add `description: pkg.description` to every plugin `index.ts`
- Add optional `tags` field on Command as array of strings
- Add mandatory `usage` field on Command, and refactor all commands to expose it
- Add appropriate lookup dictionaries to `PluginRuntime` class

### New Plugins

- Add `@or-q/cli` dependency on `@or-q/help`
- export `tagHelpCommand` constant from `@or-q/plugin-help` and use it in help command definitions
- export `tagDiscoverCommand` constant from `@or-q/plugin-discover` and use it in discover command definitions

### Command Usage Refactoring

The main challenge of the Proposal is to address implicit technical debt of the command `usage`, which is currently
hardcoded in `Command.run()` implementations without violating DRY on usage text, given that the core as written now
does not currently "know" which command is being executed.

We address that by sidestepping the problem and improving the code layout at the same time, while incidentally ticking a
couple of pre-existing `TODO.md` items:

1. Reorganize code of each plugin:
   - The `src/index.ts` is the plugin definition, commands are defined in other files. Reference:
     [@or-q/plugin-core/index.ts](../../../packages/plugin-core/src/index.ts)

   - One file per command, commands are in `src/commmands/`.

   - If a plugin already had commands in separate files (e.g. `src/debug.ts`), place commands from it as files in a
     subdirectory (e.g. `src/debug/dump.ts`).

2. Define `usage` string as a contant in outer scope of a command implementation file.

Pros:

- Much better command list and command source discoverability
- `usage` is written once, and then referenced both in `run` and in `Command.usage`

Cons:

- Unwieldy `index.ts` barrel-like files, which is acceptable.

## Testing Strategy

Manual smoke tests.

Write dumb `test-<commmand>.yaml` scripts for each command.

Run the script, study the output.

### Future work

`Command Usage Refactoring` implies smoke tests for all commands.

The scripts will later become a basis for initial test suites.

## Implementation Notes

### Strategy

1. Core Interface Enhancements
   - Enhance Command interface with mandatory tags and usage fields
   - Add mandatory description field to Plugin interface
   - Remove `IPluginRuntime.usage()` method entirely
   - Update all existing commands and plugins to include these fields

2. Code Reorganization
   - Move all commands to `src/commands/` directories with one file per command
   - Define usage string as a constant in each command file
   - Add appropriate tags to all commands
   - Smoke test each command after reorganization to ensure functionality
   - Plugin Implementation

3. Create both `@or-q/plugin-help` and @`or-q/plugin-discover` simultaneously
   - Implement all commands specified in the proposal
   - Export tag constants (`tagHelpCommand`, `tagDiscoverCommand`) from respective plugins
   - Add `@or-q/cli` dependency on `@or-q/plugin-help`
   - Update CLI to use help command when invoked with no arguments
   - YAML Script Enhancements

4. Add support for description field in YAML scripts
   - Implement script-specific help and discover commands
   - Update all existing scripts with descriptions

5. Legacy Command Removal
   - Remove all legacy commands (`list-plugins`, `plugins-json`, etc.)
   - Update any references to use new command patterns

6. Testing
   - Write `test-<command>.yaml` scripts for each new command
   - Perform manual smoke tests for all commands
   - Verify output formats match specifications

### Recommended Order

#### Phase 1: Core Interface Foundation (Optional Fields)

T1. **Enhance Command interface** - Add `tags?: string[]` and `usage?: string` as optional fields T2. **Enhance Plugin
interface** - Add `description?: string` as optional field T3. **Remove legacy** - Delete `IPluginRuntime.usage()`
method, output stub in cli on no-args

**Rationale**: Optional fields allow existing plugins to continue working unchanged.

#### Phase 2: New Plugin Implementation (with Graceful Degradation)

T4. **Create plugin-help package** - Implement all `help-*` commands with fallbacks for missing metadata T5. **Create
plugin-discover package** - Implement all `discover-*` commands with null handling T6. **Export tag constants** -
`tagHelpCommand`, `tagDiscoverCommand`

**Rationale**: Help system can work immediately, showing "No description available" or empty arrays for missing data.

#### Phase 3: Incremental Plugin Updates

T7. **Update plugin-core first** - Add descriptions, usage, tags, reorganize to `src/commands/` T8. **Test help
system** - Verify help commands work with mixed old/new plugins T9. **Update remaining plugins one by one** - Each
becomes fully documented as updated T10. **Validate after each plugin** - Ensure no regressions

**Rationale**: System remains functional throughout; each plugin improvement is immediately visible.

#### Phase 4: Integration & Enhancement

T11. **Update CLI integration** - Add dependency, implement full no-args behavior T12. **YAML script descriptions** -
Add description field support T13. **Update existing scripts** - Add descriptions to all YAML assets

#### Phase 5: Make Fields Required & Cleanup

T14. **Make Command fields required** - `tags: string[]`, `usage: string` T15. **Make Plugin description required** -
`description: string` T16. **Remove legacy commands** - `list-plugins`, `plugins-json`, etc. T17. **Comprehensive
testing** - Write test scripts for all commands

**Rationale**: Only enforce requirements after all plugins are updated; breaking changes come last.

#### Key Benefits

- **Zero downtime**: System always works during migration
- **Incremental value**: Help improves as each plugin gets updated
- **Safe rollback**: Any step can be reverted without breaking the system
- **Early feedback**: Help system can be tested and refined before making fields required

#### Dependencies

- **Phases 1-2 are sequential** (interface changes must precede help implementation)
- **Phase 3 can be done incrementally** (one plugin at a time)
- **Phases 4-5 require Phase 3 completion**

This approach follows the principle of "make the change easy, then make the easy change."

## Comprehensive Implementation Plan

### Current Status (Phases 1-2 Complete ✅)

- Enhanced Command and Plugin interfaces with optional tags/usage/description fields
- Created @or-q/plugin-help and @or-q/plugin-discover packages with all required commands
- Removed legacy IPluginRuntime.usage() method

### Complete Command Inventory

#### Command Distribution by Plugin

1. **@or-q/plugin-core**: 27 commands (40%) - **Needs reorganization to src/commands/**
   - assets.ts: list-assets, cat → `src/commands/assets/list-assets.ts`, `src/commands/assets/cat.ts`
   - debug.ts: dump → `src/commands/debug/dump.ts`
   - error.ts: fail → `src/commands/fail.ts`
   - formats.ts: tsv → `src/commands/formats/tsv.ts`
   - functional.ts: head, map, map-n, parallel-map-n → `src/commands/functional/` directory
   - input.ts: prepend, append → `src/commands/input/` directory
   - io.ts: -, print, tee, input, echo, default, clear, readline → `src/commands/io/` directory
   - log.ts: spam, debug, info, log, warn, error, none → `src/commands/log/` directory
   - plugins.ts: list-plugins, plugins-json → `src/commands/plugins/` directory
   - string.ts: unquote, quote, replace, trim, trimStart, trimEnd → `src/commands/string/` directory

2. **@or-q/plugin-openrouter-api**: 7 commands (10%) - **Needs reorganization to src/commands/**
   - completions.ts: completions → `src/commands/completions.ts`
   - conversation.ts: conversation, system, user, assistant, tool, temperature → `src/commands/conversation/` directory
   - models.ts: models → `src/commands/models.ts`

3. **@or-q/plugin-filesystem**: 7 commands (10%) - **Needs reorganization to src/commands/**
   - file.ts: cat-file, file → `src/commands/file/` directory
   - dirtree.ts: dirtree-json, dirtree-annotated-json, dirtree → `src/commands/dirtree/` directory
   - glob.ts: glob, glob3 → `src/commands/glob/` directory
   - ignore.ts: ignore → `src/commands/ignore.ts`

4. **@or-q/plugin-fetch**: 1 command (1%) - **Needs reorganization to src/commands/**
   - fetch.ts: fetch → `src/commands/fetch.ts`

5. **@or-q/plugin-ollama**: 3 commands (4%) - **Needs reorganization to src/commands/**
   - ollama.ts: ollama-generate, ollama-chat → `src/commands/ollama/` directory
   - openai.ts: ollama → `src/commands/ollama-openai.ts`

6. **@or-q/plugin-yaml-script**: 6 commands (9%) - **Needs reorganization to src/commands/**
   - All in index.ts: exec, list-script-assets, run, forever, \_DATA, \_JSON → separate files

7. **@or-q/plugin-store**: 5 commands (7%) - **Needs reorganization to src/commands/**
   - All in index.ts: load, save, set, setdata, dump-store → separate files

8. **@or-q/plugin-macro**: 4 commands (6%) - **Needs reorganization to src/commands/**
   - All in index.ts: $defmacro, $macro, $arg, dump-macros → separate files

9. **@or-q/plugin-template**: 3 commands (4%) - **Needs reorganization to src/commands/**
   - All in index.ts: t, f, render → separate files

10. **@or-q/plugin-format**: 2 commands (3%) - **Needs reorganization to src/commands/**
    - All in index.ts: pretty, yaml → separate files

11. **@or-q/plugin-jp**: 1 command (1%) - **Needs reorganization to src/commands/**
    - index.ts: jp → `src/commands/jp.ts`

12. **@or-q/plugin-shell**: 1 command (1%) - **Needs reorganization to src/commands/**
    - index.ts: shell → `src/commands/shell.ts`

13. **@or-q/plugin-stdio-logger**: 1 command (1%) - **Needs reorganization to src/commands/**
    - index.ts: stdio-loglevel → `src/commands/stdio-loglevel.ts`

#### Current Metadata Status

- **Commands with usage strings**: 32 (47%) - Need to extract to constants
- **Commands without usage strings**: 36 (53%) - Need usage added
- **Commands with tags**: 0 (0%) - All need appropriate tags
- **Commands with descriptions**: 68 (100%) - All have descriptions

### Remaining Work: ~150+ Tasks

#### Phase 3: Plugin Reorganization (All plugins need src/commands/ structure)

**Large Multi-Category Plugins (27+ commands each):**

- **plugin-core**: 27 commands across 9 categories → src/commands/ with category subdirectories

**Medium Multi-Category Plugins (3-7 commands):**

- **plugin-openrouter-api**: 7 commands → src/commands/ with conversation/ subdirectory
- **plugin-filesystem**: 7 commands → src/commands/ with file/, dirtree/, glob/ subdirectories
- **plugin-yaml-script**: 6 commands → src/commands/ individual files
- **plugin-store**: 5 commands → src/commands/ individual files
- **plugin-macro**: 4 commands → src/commands/ individual files
- **plugin-template**: 3 commands → src/commands/ individual files
- **plugin-ollama**: 3 commands → src/commands/ with ollama/ subdirectory

**Small Single-Category Plugins (1-2 commands):**

- **plugin-format**: 2 commands → src/commands/ individual files
- **plugin-fetch**: 1 command → src/commands/fetch.ts
- **plugin-jp**: 1 command → src/commands/jp.ts
- **plugin-shell**: 1 command → src/commands/shell.ts
- **plugin-stdio-logger**: 1 command → src/commands/stdio-loglevel.ts

**Each plugin requires:**

1. Create src/commands/ directory structure
2. Move commands to individual files (one command per file)
3. Add usage constants to each command file
4. Add appropriate tags to each command
5. Update main index.ts to import from commands/ and add description
6. Ensure all commands have proper metadata

#### Phase 4: Testing & Validation (24 tasks)

**Smoke Test Creation:**

- **Help/Discover commands**: 13 test scripts for new help system commands
- **All existing commands**: 10 task groups covering all 68 commands across all plugins
- **System validation**: 1 comprehensive validation task

**Test Script Structure:** Each command gets a `test-<command>.yaml` script in the plugin's `assets/scripts/` directory
following this pattern:

```yaml
description: Smoke test for <command> command
commands:
  - echo "test input"
  - <command> [args]
  - tee
```

#### Phase 5: Integration & Cleanup (6 tasks)

**YAML Script Enhancements:**

- Add description field support to YAML scripts
- Add help-scripts, help-script, discover-scripts, discover-script commands

**Legacy Command Removal:**

- Remove list-plugins → help-plugins
- Remove list-assets → help-assets
- Remove list-script-assets → help-scripts
- Remove plugins-json → discover-plugins
- Remove dump-macros → discover-macros
- Remove dump-store → discover-store

**CLI Integration:**

- Add @or-q/plugin-help dependency to CLI
- Update CLI to check for help command existence and execute it
- Add both plugins to workspace dependencies
- Run pnpm install

### Implementation Priority Order

1. **Complete plugin-core updates** (highest impact, 40% of commands)
2. **Plugin reorganizations** (structural changes)
3. **Add descriptions to already-organized plugins**
4. **Create smoke tests** (validation)
5. **YAML script enhancements**
6. **Legacy command removal** (breaking changes last)
7. **Final integration and testing**

This comprehensive plan ensures all 68 commands across 13 plugins will be properly documented, organized, and tested
according to P0001 specifications.
