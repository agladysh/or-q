# OR-Q Codebase Analysis: P0001-Derived Notes

> [!WARNING] _This document was generated by an AI and may contain mistakes._

These are detailed technical notes derived from studying the codebase for P0001 (Help Plugin Implementation). This
document captures all discovered nuances and will be redistilled into proper documentation later.

> [!WARNING] \_This document IS NOT A SOURCE OF TRUTH, is provided for the reference, may be obsolete, and shall be
> replaced with proper professional codebase documentation.

## Command Interface and Usage String Patterns

### Current Command Structure

**Command Interface** (`/packages/lib/src/index.ts:25-28`):

```typescript
export interface Command {
  description: string;
  run: (input: string | Readable, args: Arguments, runtime: IPluginRuntime) => Promise<string | Readable>;
}
```

**Key Findings**:

- Commands currently have only `description` and `run` fields
- No `tags` field exists yet (needed for P0001)
- No `usage` field exists - usage strings are hardcoded in `commandArgument()` calls

### Usage String Patterns Analysis

**Current Pattern**: Usage strings are hardcoded in `commandArgument()` calls throughout the codebase.

**Examples Found**:

```typescript
// Simple patterns
'usage: jp "[JMESPath query string]"';
'usage: shell "[shell command]"';
'usage: run "<file>"';
'usage: cat "<file>"';

// Multi-argument patterns
'usage: glob "pattern" "ignore-pattern"';
'usage: set "<key>" "<value>"';
'usage: $defmacro <name> <def>'
// Dynamic patterns
`usage: ${command} "<message>"` // in conversation.ts
`usage: loglevel "${logLevelNames.join('|')}"`; // in stdio-logger

// Complex patterns
('usage: glob "pattern" "ignore-pattern" "options"'); // glob-advanced
```

**Usage String Conventions**:

- Always start with `usage:`
- Command name followed by arguments
- Required arguments in `"<description>"` or `"value"`
- Optional arguments in `[brackets]` (rare due to architectural constraints)
- Multiple arguments space-separated
- Dynamic values use template literals

**Refactoring Challenge**: Usage strings are currently:

1. **Hardcoded** in each command implementation
2. **Inconsistent** in format and style
3. **Not accessible** for help system without parsing source code
4. **Duplicated** when same usage appears in multiple places

### commandArgument() Function Analysis

**Location**: `/packages/lib/src/index.ts:116-131`

```typescript
export async function commandArgument(
  runtime: IPluginRuntime,
  arg: string | Arguments | undefined,
  usage: string,
  input: string | Readable = ''
): Promise<string> {
  if (arg === undefined) {
    return fail(usage); // Throws PluginRuntimeFailure with usage string
  }

  if (!Array.isArray(arg)) {
    return arg; // Simple string argument
  }

  return readableToString(await runtime.runCommands(input, arg)); // Nested command execution
}
```

**Key Insights**:

- Usage string is only used for error messages when argument is missing
- Function supports nested command execution (when arg is Arguments array)
- No validation of argument format against usage pattern
- Usage string is not stored or accessible outside error context

## Plugin Architecture and Metadata

### Plugin Interface Structure

**Current Plugin Interface** (`/packages/lib/src/index.ts:78-83`):

```typescript
export interface Plugin<E extends IPluginRuntimeEvent = IPluginRuntimeEvent> {
  name: string;
  eventListeners?: IPluginRuntimeEventListeners<E>;
  assets?: Assets;
  commands?: Commands;
}
```

### Plugin Implementation Patterns

**Standard Plugin Structure**:

```typescript
// packages/plugin-*/src/index.ts
import { mergeCommands, type Plugin } from '@or-q/lib';
import pkg from '../package.json' with { type: 'json' };

const plugin: Plugin = {
  name: pkg.name, // Uses package.json name
  commands: mergeCommands(pkg.name, [
    /* command modules */
  ]),
  // Optional: assets: loadModuleAssets(import.meta.url),
};

export default plugin;
```

**Plugin Metadata Available**:

- `pkg.name` - Package name from package.json
- `pkg.description` - Package description (not currently used in Plugin interface)
- `pkg.version`, `pkg.author`, `pkg.license` - Available but not exposed

**Missing Plugin Metadata**:

- No `description` field in Plugin interface
- Package.json description not accessible through runtime
- No way to get plugin version, author, license through runtime

### Runtime Plugin Information

**Available at Runtime**:

```typescript
interface IPluginRuntime {
  plugins: PluginRecord; // Record<string, Plugin>
  pluginNames: string[]; // Array of plugin names
  commandNames: string[]; // Flattened command names
  assetNames: string[]; // Prefixed asset names
  commands: Commands; // Flattened command registry
  assets: Assets; // Prefixed asset registry
}
```

**Plugin Resolution Process** (`/packages/core/src/index.ts:102-108`):

1. `listAllPluginModules()` scans node_modules for `/((^@or-q\/plugin-)|(or-q-plugin))/`
2. Dynamic imports load each plugin module
3. `resolveRecord()` flattens commands and assets with conflict warnings
4. Assets get prefixed with `plugin:${plugin.name}/`

**Plugin Information Gaps**:

- No access to package.json metadata beyond name
- No plugin descriptions available
- No version information
- No dependency information

## Asset System Analysis

### Asset Structure and Resolution

**Asset Types**:

- **YAML Scripts**: Primary asset type, stored in `assets/scripts/` directories
- **Other Files**: Any file in plugin `assets/` directories

**Asset Resolution Hierarchy** (`/packages/lib/src/index.ts:233-249`):

1. **Direct URI**: `plugin:package-name/path`, `file:///absolute`, `./relative`
2. **Plugin Glob Search**: `assetGlob(runtime, 'plugin:*/**/scripts/**/${uri}.yaml')`
3. **Filesystem Fallback**: For qualified paths only

**Asset Naming Convention**:

- Assets prefixed with `plugin:${plugin.name}/` in runtime
- Scripts typically in `scripts/` subdirectory
- YAML extension for scripts

**Current Asset Commands**:

- `list-assets`: Prints all assets to stdout, passes input along
- `cat`: Loads asset content, replaces input
- `list-script-assets`: YAML-script specific asset listing

### YAML Script Structure

**Script Interface** (`/packages/plugin-yaml-script/src/index.ts:22-26`):

```typescript
interface Script {
  requires: [string]; // Plugin dependencies (validation only)
  ['on-empty-stdin']: CommandList; // Conditional execution
  commands: CommandList; // Main command sequence
}
```

**Missing Fields for P0001**:

- No `description` field for script documentation
- No `usage` field for script parameters
- No `tags` field for categorization

**Script Examples Found**:

```yaml
# Simple script
requires:
  - '@or-q/plugin-openrouter-api'
  - '@or-q/plugin-jp'
commands:
  - models
  - jp: data[?pricing.prompt=='0' && pricing.completion=='0']

# Complex script with macros
requires:
  - '@or-q/plugin-fetch'
commands:
  - $defmacro:
      - $fetch-openai-instruct
      - [/* macro definition */]
  - $macro: [[$fetch-openai-instruct, /* args */]]
```

## Existing dump/list Commands Analysis

### Commands to Replace/Migrate

**Core Plugin Commands**:

1. **`dump`** (`plugin-core/src/debug.ts:5`):
   - Description: "replaces input with remaining program dump"
   - Function: Returns `JSON.stringify(args)` - debugging tool
   - **Replacement**: Should become `discover-program-args` or similar

2. **`list-plugins`** (`plugin-core/src/plugins.ts:5`):
   - Description: "prints the list of available plugins to stdout, passes input along"
   - Function: Prints plugin names to stdout, passes input forward
   - **Replacement**: Should become `help-plugins` (human-readable)

3. **`plugins-json`** (`plugin-core/src/plugins.ts:12`):
   - Description: "replaces input with a full information on available plugins"
   - Function: Returns `JSON.stringify(runtime.plugins)`
   - **Replacement**: Should become `discover-plugins` (machine-readable)

4. **`list-assets`** (`plugin-core/src/assets.ts:14`):
   - Description: "prints the list of available assets to stdout, passes input along"
   - Function: Prints asset names with basenames to stdout
   - **Replacement**: Should become `help-assets`

**Plugin-Specific Commands**:

1. **`dump-macros`** (`plugin-macro/src/index.ts:94`):
   - Description: "replaces input with macros saved as JSON"
   - Function: Prints macro registry to stdout, passes input forward
   - **Replacement**: Should become `discover-macros`

2. **`dump-store`** (`plugin-store/src/index.ts:60`):
   - Description: "dumps store content to stdout as JSON, passes input forward"
   - Function: Prints store content to stdout
   - **Replacement**: Should become `discover-store`

3. **`list-script-assets`** (`plugin-yaml-script/src/index.ts:268`):
   - Description: "prints the list of available builtin scripts to stdout, passes input along"
   - Function: Lists YAML script assets
   - **Replacement**: Should become `help-scripts`

### Command Behavior Patterns

**Two Distinct Patterns**:

1. **stdout + pass-through**: Print to stdout, pass input forward (list-\* commands)
2. **replace input**: Replace input with JSON data (dump-_,_-json commands)

**P0001 Mapping**:

- **stdout + pass-through** → `help-*` commands (human-readable)
- **replace input** → `discover-*` commands (machine-readable JSON)

## Runtime Information Access Patterns

### Available Runtime Data

**Command Information**:

```typescript
runtime.commands: Commands // All commands with descriptions
runtime.commandNames: string[] // Command names only
```

**Plugin Information**:

```typescript
runtime.plugins: PluginRecord // Full plugin objects
runtime.pluginNames: string[] // Plugin names only
```

**Asset Information**:

```typescript
runtime.assets: Assets // Asset content by prefixed name
runtime.assetNames: string[] // Prefixed asset names
```

### Information Gaps for P0001

**Missing Command Metadata**:

- No usage strings accessible
- No command tags/categories
- No command grouping by plugin (need to reverse-engineer)

**Missing Plugin Metadata**:

- No plugin descriptions
- No package.json metadata access
- No plugin version information

**Missing Asset Metadata**:

- No asset descriptions
- No script parameter documentation
- No asset categorization

## CLI Integration Analysis

### Current No-Args Behavior

**Location**: `/packages/cli/src/main.ts:10-14`

```typescript
if (args.length === 0) {
  // Lazy: should write full help
  process.stdout.write(`${runtime.usage()}\n`);
  return;
}
```

**Current `runtime.usage()`** (`/packages/core/src/index.ts:111-113`):

```typescript
usage(): string {
  return `Available commands: ${this.commandNames.join(', ')}`;
}
```

**P0001 Requirements**:

1. Check if `help` command exists in runtime
2. If yes, execute `help` command
3. If no, show fallback message recommending `@or-q/plugin-help`

**Implementation Strategy**:

```typescript
if (args.length === 0) {
  if ('help' in runtime.commands) {
    const helpOutput = await runtime.runCommands('', ['help']);
    process.stdout.write(`${await readableToString(helpOutput)}\n`);
  } else {
    process.stdout.write('help command not available, install the @or-q/plugin-help npm package\n');
  }
  return;
}
```

## Command Metadata Enhancement Requirements

### Required Interface Changes

**Enhanced Command Interface**:

```typescript
export interface Command {
  description: string;
  usage?: string; // New: extracted from hardcoded strings
  tags?: string[]; // New: for categorization
  run: (input: string | Readable, args: Arguments, runtime: IPluginRuntime) => Promise<string | Readable>;
}
```

**Enhanced Plugin Interface**:

```typescript
export interface Plugin<E extends IPluginRuntimeEvent = IPluginRuntimeEvent> {
  name: string;
  description?: string; // New: from package.json
  eventListeners?: IPluginRuntimeEventListeners<E>;
  assets?: Assets; // Fix: was incorrectly typed as Commands
  commands?: Commands;
}
```

**Enhanced Script Interface**:

```typescript
interface Script {
  description?: string; // New: for help system
  requires: [string];
  ['on-empty-stdin']: CommandList;
  commands: CommandList;
}
```

### Tag System Design

**Proposed Tag Constants** (to be exported from `@or-q/plugin-help`):

```typescript
export const tagHelpCommand = 'help-command';
export const tagDiscoverCommand = 'discovery-command';
```

**Tag Usage Examples**:

```typescript
const commands: Commands = {
  help: {
    description: 'Shows available help commands',
    tags: [tagHelpCommand],
    run: async (/* ... */) => {
      /* ... */
    },
  },
  'discover-commands': {
    description: 'Returns all commands as JSON',
    tags: [tagDiscoverCommand],
    run: async (/* ... */) => {
      /* ... */
    },
  },
};
```

## Output Format Analysis

### Current Output Patterns

**Human-Readable Formats** (from existing list-\* commands):

```text
Available plugins:

@or-q/plugin-yaml-script
@or-q/plugin-template
@or-q/plugin-store
...

Available assets:

* fetch-test.yaml plugin:@or-q/plugin-fetch/scripts/fetch-test.yaml
* openrouter-gpt-oss-free-instruct.yaml plugin:@or-q/plugin-openrouter-api/scripts/openrouter-gpt-oss-free-instruct.yaml
...
```

**Machine-Readable Formats** (from existing \*-json commands):

```json
{
  "@or-q/plugin-core": {
    "name": "@or-q/plugin-core",
    "commands": {
      "dump": { "description": "replaces input with remaining program dump" },
      "list-plugins": { "description": "prints the list of available plugins to stdout, passes input along" }
    }
  }
}
```

### Required Output Formats for P0001

**Help Command Outputs** (human-readable):

- Grouped by plugin with descriptions
- Sorted alphabetically
- Clear formatting with consistent spacing

**Discover Command Outputs** (machine-readable):

- Complete JSON objects with all metadata
- Consistent structure across all discover-\* commands
- Filterable with `jp` command

## Implementation Challenges and Solutions

### Challenge 1: Usage String Extraction

**Problem**: Usage strings are hardcoded in `commandArgument()` calls **Solution Options**:

1. **Manual Migration**: Extract each usage string to command metadata
2. **Parser Approach**: Parse TypeScript source to extract usage strings
3. **Runtime Approach**: Modify `commandArgument()` to register usage strings

**Recommended**: Manual migration with linting rule to enforce usage field

### Challenge 2: Plugin Description Access

**Problem**: Package.json descriptions not accessible in Plugin interface **Solution**: Modify each plugin to include
`description: pkg.description`

### Challenge 3: Command-to-Plugin Mapping

**Problem**: Runtime flattens commands, losing plugin association **Solution**: Reverse-engineer from command names or
enhance runtime to preserve mapping

### Challenge 4: Asset Description System

**Problem**: No metadata system for assets **Solution**:

1. Add optional `description` field to Script interface
2. Create asset metadata registry
3. Use filename conventions for categorization

### Challenge 5: Backward Compatibility

**Problem**: Adding fields to interfaces may break existing plugins **Solution**: Make all new fields optional with
sensible defaults

## Migration Strategy

### Phase 1: Interface Enhancement

1. Add optional `tags` and `usage` fields to Command interface
2. Add optional `description` field to Plugin interface
3. Add optional `description` field to Script interface
4. Export tag constants from `@or-q/plugin-help`

### Phase 2: Core Plugin Updates

1. Add `description: pkg.description` to all plugin index.ts files
2. Extract usage strings from `commandArgument()` calls to command metadata
3. Add appropriate tags to existing commands

### Phase 3: Help System Implementation

1. Create `@or-q/plugin-help` with help-\* commands
2. Create `@or-q/plugin-discover` with discover-\* commands
3. Update CLI to use help command when available

### Phase 4: Legacy Command Migration

1. Deprecate existing dump/list commands
2. Update documentation to reference new help/discover commands
3. Eventually remove deprecated commands

## Technical Debt and Lazy Comments

**Found "Lazy" Comments Related to P0001**:

1. `/packages/cli/src/main.ts:11` - "Lazy: should write full help"
2. `/packages/core/src/index.ts:111` - "Lazy. This does not belong here." (usage method)
3. `/packages/lib/src/index.ts:115` - "Lazy. Too low-level. Rearchitect." (commandArgument)
4. `/packages/plugin-core/src/assets.ts:17` - "Lazy. Sort by name, so duplicates are clearly visible."

**Implications**: The help system is acknowledged technical debt that needs proper implementation.

## Conclusion

This analysis reveals that implementing P0001 requires:

1. **Interface enhancements** for metadata support
2. **Systematic migration** of hardcoded usage strings
3. **New plugin architecture** for help and discovery
4. **CLI integration** for seamless user experience
5. **Careful migration strategy** to maintain backward compatibility

The codebase is well-structured for this enhancement, with clear separation of concerns and consistent patterns that can
be extended systematically.
