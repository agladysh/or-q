# P0002: Test Timeout Support

Status: **DRAFT**

> [!WARNING] This document is partially generated by AI for AI and may contain mistakes.

## Summary

This proposal outlines the implementation of timeout support in the OR-Q test system (`@or-q/plugin-test`), enabling
testing of long-running commands like `forever` and `ollama` while providing safety timeouts for all tests.

## Motivation

### Current Limitations

The OR-Q test system currently lacks timeout support, creating several problems:

1. **Infinite hangs**: Tests for commands like `forever` cannot be written, as they would hang indefinitely
2. **No safety net**: Slow or broken commands can cause test runs to hang forever
3. **P0001 roadmap blocked**: Phase 2 test fixes require timeout support for `forever` command testing
4. **API command testing**: Commands like `ollama-generate` need longer timeouts for model loading

### Architecture Gap

While the underlying infrastructure supports timeouts:

- `SpawnOptions` interface has `timeout` field (milliseconds)
- `spawnTest` function accepts and uses timeout parameter
- Test schema has **no timeout field**, preventing YAML tests from specifying timeouts

## Requirements

### Functional Requirements

1. **Optional timeout field** in test YAML schema
2. **Timeout in seconds** (human-readable, consistent with user expectations)
3. **Default 30-second timeout** for all tests (prevent hanging)
4. **Special timeout exit code** (`"timeout"` string) to distinguish from normal exit codes
5. **Output capture during timeout** (stdout/stderr collected before process termination)
6. **Backwards compatibility** with existing tests

### Use Cases

#### Long-Running Commands

```yaml
# ollama command needs time for model loading
- name: smoke
  argv: ollama-generate
  stdin: 'test prompt'
  timeout: 120 # 2 minutes
  stdout:
    - contains: '"response"'
```

#### Expected Timeout Commands

```yaml
# forever command should timeout
- name: smoke-timeout
  argv: forever "echo test"
  stdin: ''
  timeout: 1 # 1 second
  exit: 'timeout'
  stdout:
    - contains: 'test'
```

#### Default Timeout Protection

```yaml
# Normal command with safety timeout
- name: smoke
  argv: echo "hello"
  stdout: 'hello'
  # timeout: 30 (default)
```

## Design

### Schema Changes

**Current Schema** (`packages/plugin-test/src/lib/schema.ts`):

```typescript
test: {
  name: 'string > 0',
  argv: 'string|string[]',
  stdin: 'string',
  stdout: 'stream = ""',
  stderr: 'stream = ""',
  exit: 'number=0',
},
```

**Proposed Schema**:

```typescript
test: {
  name: 'string > 0',
  argv: 'string|string[]',
  stdin: 'string',
  stdout: 'stream = ""',
  stderr: 'stream = ""',
  exit: 'number|"timeout"=0',  // Allow "timeout" string
  timeout: 'number > 0 = 30',  // Seconds, default 30
},
```

### Implementation Changes

#### 1. SpawnTest Function Update

**File**: `packages/plugin-test/src/lib/index.ts`

**Key Changes**:

- Accept timeout in seconds, convert to milliseconds internally
- Use local timeout flag instead of signal detection
- Return `"timeout"` exit code when timeout occurs
- Capture stdout/stderr before timeout

```typescript
interface SpawnTestResult {
  stdout: string;
  stderr: string;
  code: number | 'timeout'; // Allow timeout string
}

async function spawnTest(cmd: string, input: Readable | string, opts: SpawnOptions = {}): Promise<SpawnTestResult> {
  const { args = [], timeout } = opts;

  let timedOut = false; // Local flag for reliable timeout detection

  const child = spawn(cmd, args, {
    stdio: ['pipe', 'pipe', 'pipe'],
    shell: false,
  });

  if (timeout) {
    const timer = setTimeout(() => {
      timedOut = true; // Set flag before killing
      child.kill('SIGTERM');
    }, timeout * 1000); // Convert seconds to milliseconds

    child.on('exit', () => clearTimeout(timer));
  }

  // ... stdin/stdout/stderr handling ...

  return new Promise<SpawnTestResult>((resolve, reject) => {
    child.on('close', async (code, signal) => {
      // Use local flag instead of signal detection
      const exitCode = timedOut ? 'timeout' : (code ?? 0);

      resolve({
        stdout: Buffer.concat(stdout).toString('utf8'),
        stderr: Buffer.concat(stderr).toString('utf8'),
        code: exitCode,
      });
    });
  });
}
```

#### 2. Test Runner Integration

**File**: `packages/plugin-test/src/lib/index.ts`

```typescript
// In test execution loop:
const result = await spawnTest('pnpm', input, {
  args: ['or-q', ...argv],
  timeout: test.timeout, // Pass timeout from test spec
});

// Exit code validation handles both numbers and "timeout"
if (result.code !== test.exit) {
  yield`\tFAIL\tTEST\t${test.name}\texit code mismatch: expected ${test.exit}, got ${result.code}\n`;
  ++testErrors;
}
```

### Timeout Detection Strategy

**Problem**: Cannot distinguish our intentional SIGTERM from external signals.

**Solution**: Use local timeout flag set before sending SIGTERM.

**Benefits**:

- ✅ **Reliable detection**: Only our timeout sets the flag
- ✅ **External signal safe**: Random SIGTERM won't trigger timeout logic
- ✅ **Race condition safe**: Flag set synchronously before kill()
- ✅ **Clear semantics**: Explicit timeout vs normal termination

## Test Plan

### Self-Testing Strategy

Following existing test plugin patterns, create timeout-specific test fixtures:

#### Timeout Success Tests

**File**: `packages/plugin-test/assets/fixtures/timeout-success.yaml`

```yaml
suite: Timeout Success Tests
requires:
  - '@or-q/plugin-core'
  - '@or-q/plugin-yaml-script'
tests:
  - name: default-timeout-fast
    argv: echo fast
    stdin: ''
    stdout: 'fast'
    # Uses 30s default timeout

  - name: explicit-timeout-fast
    argv: echo fast
    stdin: ''
    timeout: 5
    stdout: 'fast'

  - name: expected-timeout
    argv: forever "echo test"
    stdin: ''
    timeout: 1
    exit: 'timeout'
    stdout:
      - contains: 'test'
```

#### Timeout Failure Tests

**File**: `packages/plugin-test/assets/fixtures/timeout-fail.yaml`

```yaml
suite: Timeout Failure Tests
requires:
  - '@or-q/plugin-core'
  - '@or-q/plugin-yaml-script'
tests:
  - name: unexpected-timeout
    argv: forever "echo test"
    stdin: ''
    timeout: 1
    exit: 0 # Wrong! Should be "timeout"
    stdout:
      - contains: 'test'

  - name: expected-timeout-but-succeeded
    argv: echo fast
    stdin: ''
    timeout: 5
    exit: 'timeout' # Wrong! Should be 0
    stdout: 'fast'
```

### Integration with Existing Infrastructure

- **Automatic validation**: Timeout fixtures integrated into existing `test-run-test-suite.yaml` flow
- **Expected output generation**: `.txt` files generated for new fixtures
- **Consistent patterns**: Follow exact naming and structure of existing fixtures

## Implementation Plan

### Phase 1: Core Timeout Support

1. **Update test schema** with timeout and timeout exit support
2. **Modify spawnTest function** with local timeout flag implementation
3. **Update test runner logic** to handle timeout exit conditions
4. **Verify schema validation** works with new fields

### Phase 2: Test Coverage

1. **Create timeout success fixtures** following existing patterns
2. **Create timeout failure fixtures** for negative testing
3. **Generate expected output files** for new fixtures
4. **Verify integration** with test-run-test-suite infrastructure

### Phase 3: Real-World Testing

1. **Update forever command test** to use timeout support
2. **Update ollama command tests** with 120s timeout
3. **Verify P0001 roadmap examples** work with new schema
4. **Run full test suite** to ensure no regressions

## Backwards Compatibility

### Existing Tests

- **No changes required**: All existing tests continue working
- **Default timeout applied**: 30s timeout added automatically
- **Exit code compatibility**: Existing numeric exit codes unchanged

### Schema Evolution

- **Optional fields**: `timeout` field is optional with sensible default
- **Union type**: `exit` field accepts both numbers and `"timeout"` string
- **Graceful degradation**: Tests without timeout field work normally

## Success Criteria

1. ✅ **Timeout schema validation** works for all field combinations
2. ✅ **Expected timeout detection** works reliably with local flag
3. ✅ **Output capture** works during timeout scenarios
4. ✅ **Self-tests pass**: Timeout fixtures validate correctly
5. ✅ **No regressions**: Existing test fixtures continue passing
6. ✅ **P0001 unblocked**: Forever command can be tested with timeout
7. ✅ **Real-world usage**: Ollama tests work with longer timeouts

## Design Rationale

### Timeout in Seconds

- **Human readable**: More intuitive than milliseconds
- **Test focused**: Tests typically run seconds to minutes, not milliseconds
- **Conversion internal**: Millisecond precision preserved in implementation

### Default 30s Timeout

- **Safety net**: Prevents infinite hangs in broken tests
- **Reasonable duration**: Allows slow commands while catching real hangs
- **Overridable**: Can be increased for legitimately slow operations

### String Exit Code for Timeout

- **Clear semantics**: `"timeout"` is unambiguous vs numeric codes
- **Type safety**: Union type prevents confusion with normal exit codes
- **Extensible**: Pattern allows future special exit conditions

### Local Timeout Flag

- **Reliability**: Only our code can set the timeout flag
- **Signal independence**: Works regardless of termination cause
- **Race condition safe**: Synchronous flag setting before async kill

## Future Considerations

### Potential Enhancements

- **Timeout warnings**: Log when tests approach timeout
- **Configurable defaults**: Per-suite or per-plugin timeout defaults
- **Timeout categories**: Different defaults for different command types
- **Graceful termination**: Try SIGTERM, then SIGKILL after delay

### Schema Evolution

- **Timeout units**: Consider supporting both seconds and milliseconds
- **Timeout expressions**: Support relative timeouts (e.g., "2x default")
- **Signal specification**: Allow custom termination signals
- **Timeout callbacks**: Execute commands when timeout occurs

---

**Implementation Priority**: HIGH - Required for P0001 Phase 2 completion and essential test infrastructure improvement.
